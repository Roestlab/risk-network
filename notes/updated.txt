PROJECT NAME IDEA
=================
- RISK:
    ** RISK Infers Spatial Kinship **
    RISK Informs Spatial Kinship
    Regional Identification of Significant Kinships
    Regional Identification of Structural Kinships
    Regional Inference of Significant Kinships
    Reliable Inference of Subnetwork Kinship
    Reliable Inference of Spatial Kinship
    Regional Inference of Subnetwork Kinetics
    Regional Inference of Spatial Kinetics
- SPP: SAFE Plus Plus
- DANGER:
    Discovery Algorithm for Network Group Enrichment Regions
    Detection Algorithm for Network Group Enrichment Regions
    Data-driven Algorithm for Network Group Enrichment Recognition
    Dynamic Algorithm for Network Group Enrichment Revelation
    Deep Analysis Network Group Enrichment Resolver
    Discovery Approach for Network Group Enrichment Reading
    Deep Algorithm for Networked Group Enrichment Reconnaissance
    Data Analysis Network Group Enrichment Revelation
    Discovery Algorithm for Navigating Group Enrichment Research
    Data-driven Approach to Network Group Enrichment Revelation
    Data-driven Algorithms for Neighborhoods, Graphs, Exploration, and Research
    Deep Analytic Networks for Genomic Evolution Recognition
    Dynamic Assessment of Nodes, Gateways, Edges, and Routes
    Data Analysis for Network Growth, Expansion, and Reinforcement
    Discovery Algorithm for Network Genesis, Emergence, and Reconfiguration
    Deep Algorithmic Navigation of Genealogical Enrichment Relationships
    Data-driven Analysis of Network Group Ecosystems and Relations
    Discovery Algorithms for Network Geographies, Entanglements, and Repatternings
    Data Analytics for Networked Groups, Efficiencies, and Resiliencies
    Deep Analytic Network Guidance for Enrichment Realization

THINGS I UPDATED
================
1. 
    - Replaced matrix multiplication for color computation with an element-wise approach.
    - ChatGPT:
"""
Refactoring the given code block to implement an alternative to matrix multiplication for creating node colors that signify importance or enrichment involves a few steps. Given your description, it seems like you want to aggregate domain associations for each node and then apply a color mapping based on these associations. Since matmul may not be the most intuitive choice here, especially for custom logic involving color intensity or shading based on domain counts, we'll proceed with an element-wise approach that provides more control.

First, let's outline the steps needed to refactor the code block:

    Aggregate Domain Associations: Summarize the domain associations per node to determine the "weight" or "importance" of each node based on its domain counts.
    Normalize Domain Counts: Normalize these counts to ensure they fall within a range that can be mapped to colors effectively.
    Apply Color Mapping: Based on the normalized counts, apply a color mapping strategy that reflects the node's importance or enrichment.
    Implement Custom Logic for Color Intensity: Develop a logic that adjusts color intensity or shading based on the normalized domain counts. This could involve interpolating between a set of base colors and adjusting the intensity or transparency (alpha value) of the colors based on the domain count.

Since you've already aggregated domain associations (node2domain_count) and computed the total domain counts per node (node2all_domains_count), the next step is to apply the color mapping.

Assuming domain2rgb contains base colors for domains and you want to generate a composite color for each node based on its associations, here is how you can refactor the existing code block to apply a custom color mapping without using np.matmul:
"""
    - Improved coloring with appropriate shading for less enriched nodes.
2. 
    - Permutation test: now significantly faster (metrics needed to quantify this improvement).
3.
    - Accepts more intuitive annotation file types:
        - JSON
        - CSV
        - TSV
        - Excel
    - Accepts more intuitive network file types:
        - Cytoscape
        - Gpickle
        - CSV
        - TSV
        - Excel
        - SIF
    - Accepts NetworkX
4.
    - Enhanced domain description generation using NLTK.
5.
    - More explicit method for removing highly inflated domains (using Z-score to identify outliers).
    - By inflated, I mean domains with an excessively high number of members.
    - Extremely large and spatially expansive clusters are usually the result of noisy data.
6.
    - Remove node significance if its closest edge with an enriched neighbor is greater than N STDEV of all edge lengths.
7.
    - Added new domain selection algorithms:
        - Louvain
        - Affinity propagation
8. 
    - Automatically compute domain thresholding across different linkages and metrics (default behavior).
9.
    - Plot the local enrichment-finished network on a sphere.
    - Enable the sphere to rotate, capturing every rotational image to ultimately make an animation.
10. [BIG]
    - Enable the conversion of the input 2D network to 3D prior to computing neighborhoods.
        - This allows for a better spread of tightly packed nodes, facilitating a more optimal scan for local enrichment.
    - When plotting, enable the conversion of the 3D network back to a 2D plane.
11.
    - Explicitly use edge weights to better refine node distancing prior to neighborhood computation.
12.
    - Enable surface dimpling of the spherical network, clustering regions of the network with tight connections.
    - Call this the dimpling effect, with the degree of travel towards the spherical center dictated by a 'dimple factor'.
    - Automate calculation of the optimal dimple factor.
13.
    - Add contours to the network, providing a simpler way to view regions of enrichment.
14.
    - Impute non-significant nodes' significance to their closest significant node.
15.
    - Automatically generate and position labels around the network, with arrows pointing from the labels to their respective clusters.
16.
    - Seamlessly interface with the plotter class, enabling graph instantiation, display, and export.
17
    - Multiprocessed permutation test, applicable in both Python and Jupyter environments
18
    - Ability to color annotation arrows
19
    - Ability to add custom nodes / contours to the plot (labeling still needed)